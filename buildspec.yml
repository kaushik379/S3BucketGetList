version: 0.2

env:
  variables:
    AWS_REGION: "us-east-1"
    TARGET_ACCOUNT_IDS: "861530259719"
    IMAGE_REPO_NAME: "demoimages"
    LAMBDA_FUNCTION_NAME: "web-adapter-demo-ci-cd"

phases:
  pre_build:
    commands:
      - echo "Starting the build process..."
      - COMMIT_ID=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c1-7)
      - IMAGE_TAG=$COMMIT_ID
      - 'echo "GitHub Commit ID: $IMAGE_TAG"'

  build:
    commands:
      - echo "Building the Docker image with tag $IMAGE_TAG..."
      - 'docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .'

  post_build:
    commands:
      - |
        # ---- SOLUTION: ADD THIS LINE ----
        # Exit immediately if a command exits with a non-zero status.
        set -e
        # ---------------------------------

        for account_id in $TARGET_ACCOUNT_IDS; do
          echo "--------------------------------------------------"
          echo "Processing Account: $account_id"
          echo "--------------------------------------------------"

          TARGET_ECR_URI="$account_id.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_REPO_NAME"
          docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $TARGET_ECR_URI:$IMAGE_TAG

          echo "Assuming role in account $account_id..."
          # If this command fails, the script will now exit and show the actual error.
          CREDS=$(aws sts assume-role --role-arn arn:aws:iam::$account_id:role/Ai-house-ecr-lambda-sts --role-session-name "CodeBuild-Deploy-Session-$account_id")
          
          export AWS_ACCESS_KEY_ID=$(echo $CREDS | jq -r .Credentials.AccessKeyId)
          export AWS_SECRET_ACCESS_KEY=$(echo $CREDS | jq -r .Credentials.SecretAccessKey)
          export AWS_SESSION_TOKEN=$(echo $CREDS | jq -r .Credentials.SessionToken)

          echo "Checking if ECR repository exists..."
          if ! aws ecr describe-repositories --repository-names $IMAGE_REPO_NAME > /dev/null 2>&1; then
            echo "ECR repository not found. Deploying ECR CloudFormation template..."
            curl -o ecr-template.yml https://ecr-lambda-ai-house-rnd.s3.us-east-1.amazonaws.com/AiHouse-ecr-lambda.yml
            
            aws cloudformation deploy \
              --template-file ecr-template.yml \
              --stack-name create-ecr-$account_id \
              --capabilities CAPABILITY_NAMED_IAM \
              --region $AWS_REGION \
              --parameter-overrides RepositoryName=$IMAGE_REPO_NAME
          else
            echo "ECR repository already exists."
          fi

          echo "Logging in to ECR and pushing image..."
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $account_id.dkr.ecr.$AWS_REGION.amazonaws.com
          docker push $TARGET_ECR_URI:$IMAGE_TAG

          echo "Fetching image digest..."
          IMAGE_DIGEST=$(aws ecr describe-images --repository-name $IMAGE_REPO_NAME --image-ids imageTag=$IMAGE_TAG --query 'imageDetails[0].imageDigest' --output text)

          echo "Checking if Lambda function exists..."
          if ! aws lambda get-function --function-name $LAMBDA_FUNCTION_NAME > /dev/null 2>&1; then
            echo "Lambda function not found. Deploying Lambda CloudFormation template..."
            curl -o lambda-template.yaml https://s3.amazonaws.com/ecr-lambda-ai-house-rnd/ai-house-lambda-function-template.yaml
            
            aws cloudformation deploy \
              --template-file lambda-template.yaml \
              --stack-name create-lambda-$account_id \
              --capabilities CAPABILITY_NAMED_IAM \
              --region $AWS_REGION \
              --parameter-overrides LambdaImageTag=$IMAGE_TAG
          else
            echo "Updating existing Lambda function..."
            aws lambda update-function-code \
              --function-name $LAMBDA_FUNCTION_NAME \
              --image-uri "$TARGET_ECR_URI@$IMAGE_DIGEST"
          fi

          echo "Cleaning up old images..."
          # NOTE: The logic for cleaning up old images might be too aggressive, as seen in your logs where it deletes the image it just pushed.
          # You may want to adjust `tail -n +3` to `tail -n +4` or a higher number depending on how many images you wish to keep.
          image_tags_to_delete=$(aws ecr list-images --repository-name $IMAGE_REPO_NAME --query 'imageIds[*].imageTag' --output text | tr '\t' '\n' | grep -E '^[0-9a-f]{7}$' | sort -r | tail -n +3)
          if [ -n "$image_tags_to_delete" ]; then
            for tag in $image_tags_to_delete; do
              echo "Deleting old image with tag: $tag"
              aws ecr batch-delete-image --repository-name $IMAGE_REPO_NAME --image-ids imageTag=$tag || echo "Failed to delete tag $tag, continuing..."
            done
          else
            echo "No old images to delete."
          fi

          unset AWS_ACCESS_KEY_ID
          unset AWS_SECRET_ACCESS_KEY
          unset AWS_SESSION_TOKEN

          echo "Finished processing account $account_id."
          echo "--------------------------------------------------"
        done
